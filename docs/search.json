[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Muon Blog",
    "section": "",
    "text": "Vectors in R & Python: Just Use Matrices\n\n\n\n\n\n\n\nLinear Algebra\n\n\n\n\n\n\n\n\n\n\n\nMay 3, 2023\n\n\nMuon\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nApr 30, 2023\n\n\nMuon\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/vectors_in_r_python/index.html",
    "href": "posts/vectors_in_r_python/index.html",
    "title": "Vectors in R & Python: Just Use Matrices",
    "section": "",
    "text": "During my study into linear algebra, most common resources I find online, or in books, use Python and the Numpy and SciPy packages for teaching and demonstrations. With some determination and experience, it is not difficult to implement equivalent code using R. However, there are some differences in the syntax and grammar between R and Python that can confuse some users.\nI will show you how to use vectors in both R and Python, show some points of potential confusions, and lastly present you how to use matrices in R and Python.\nUltimately, I recommend working with implementations of matrices, for both R and Python, even when working with vectors. Matrices behave in ways that are consistent to how you would learn from mathematics, and both R and Python makes fewer assumptions so that you can avoid confusions."
  },
  {
    "objectID": "posts/vectors_in_r_python/index.html#using-r-python-to-study-vectors",
    "href": "posts/vectors_in_r_python/index.html#using-r-python-to-study-vectors",
    "title": "Vectors in R & Python: Just Use Matrices",
    "section": "",
    "text": "During my study into linear algebra, most common resources I find online, or in books, use Python and the Numpy and SciPy packages for teaching and demonstrations. With some determination and experience, it is not difficult to implement equivalent code using R. However, there are some differences in the syntax and grammar between R and Python that can confuse some users.\nI will show you how to use vectors in both R and Python, show some points of potential confusions, and lastly present you how to use matrices in R and Python.\nUltimately, I recommend working with implementations of matrices, for both R and Python, even when working with vectors. Matrices behave in ways that are consistent to how you would learn from mathematics, and both R and Python makes fewer assumptions so that you can avoid confusions."
  },
  {
    "objectID": "posts/vectors_in_r_python/index.html#r-vectors",
    "href": "posts/vectors_in_r_python/index.html#r-vectors",
    "title": "Vectors in R & Python: Just Use Matrices",
    "section": "R Vectors",
    "text": "R Vectors\nConstructing a vector in R is fairly trivial. You simply use the c() function and write a series of values within the parentheses.\n\nc(1,2,3,4)\n\n[1] 1 2 3 4\n\n\nAssigning a vector to a variable can be done with the code below:\n\nvector1 &lt;- c(1,2,3,4)\n\n\nVector Orientation\nIt seems to be the norm in mathematics resources for vectors to be defined as column vectors unless stated otherwise. However, the way we write vectors in code is horizontal. This makes it more intuitive for novices like me to interpret coded vectors as row vectors.\nPrinting the vector1 variable displays the vector horizontally.\n\nvector1\n\n[1] 1 2 3 4\n\n\nOne would think that to obtain the column vector of vector1 would be as trivial as passing the vector through the transpose function; t().\n\nt(vector1)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n\n\nHowever, we get a row vector. And it looks a little different. There are now numbers indexing the column position of each element of the vector.\nIf we transpose the vector again, we now get the column vector we were originally looking for. Again, this looks different from our original vector. It now shows row index numbers.\n\nt(t(vector1))\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n\n\nIf seems like out original vector was in column form all along. For those who are familiar with R, this result is not surprising. Lets take a closer look.\nIf we display our original vector:\n\nvector1\n\n[1] 1 2 3 4\n\n\nWe can see that the series of numbers starts with what looks like a row index number. However, that number in square brackets is not a row index number. It is the element index number denoting the position of the element in the vector.\nWe can display a longer vector to demonstrate this.\n\n# this is a shorthand method of displaying a vector or integers\n# between 1 and 200.\n1:200\n\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100 101 102 103 104 105 106 107 108\n[109] 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126\n[127] 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144\n[145] 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162\n[163] 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180\n[181] 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198\n[199] 199 200\n\n\nDepending on the size of your window and font, the vector of a series of integers from 1 to 200 will display using multiple lines. Each line will starts with the element number representing the first element on that new line.\nI erroneously assumed that, because vectors displayed horizontally, vectors are encoded as row vectors. However, they should be understood to follow the mathematical convention of being column vectors by default.\n\n\nAutomatic Dot Product\nNow that we know vectors are columns by default, lets try vector multiplications. Dot product, or inner product, to be exact.\n\\[\n\\mathbf{x}^{\\top}\\mathbf{y} = \\sum_{i=1}^{n}x_{i}y_{i}\n\\]\n\\[\\begin{bmatrix}\n1 & 2 & 3 & 4\\\\\n\\end{bmatrix}\n\n\\times\n\n\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\n\\end{bmatrix}\\]\nFollowing the equation, we know that the left “x” vector needs to be in row form and that the right “y” vector needs to be in the default column form. Lets try it.\n\nt(vector1) %*% vector1\n\n     [,1]\n[1,]   30\n\n\nWe obtained the expected result.\nHowever, lets say we forgot to transpose our left “x” vector.\n\nvector1 %*% vector1\n\n     [,1]\n[1,]   30\n\n\nWe can see that we obtained the dot product as we intended. It seems like R automatically assumes we wish to obtain the dot product when we perform vector multiplication with two vectors.\nR will not assume you want the outer product. If you want the outer product, you need to explicitly command it by transposing the right vector.\n\\[\\begin{bmatrix}\n1\\\\\n2\\\\\n3\\\\\n4\n\\end{bmatrix}\n\n\\times\n\n\\begin{bmatrix}\n1 & 2 & 3 & 4\\\\\n\\end{bmatrix}\\]\n\nvector1 %*% t(vector1)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    2    4    6    8\n[3,]    3    6    9   12\n[4,]    4    8   12   16\n\n\n\n\nSummary\n\nR vectors are column vectors. They are not row vectors despite being displayed horizontally.\nWhen displaying a long vector, the index number on each row represents the position of the element that starts on the new line.\nVector multiplication without transposing either vector will default to dot product."
  },
  {
    "objectID": "posts/vectors_in_r_python/index.html#python-vectors",
    "href": "posts/vectors_in_r_python/index.html#python-vectors",
    "title": "Vectors in R & Python: Just Use Matrices",
    "section": "Python Vectors",
    "text": "Python Vectors\nI will now do the same process as I did above using Python code.\nIn Python, folks usually use the array object from the Numpy package, instead of the, built-in, Python array or list objects.\n\n# import the Numpy package and give it the namespace \"np\"\nimport numpy as np\n\n\nnp.array([1,2,3,4])\n\narray([1, 2, 3, 4])\n\n\nAssigning the array to a variable is simple.\n\nvector1 = np.array([1,2,3,4])\n\n\nVector Orientation\nLets take a look at how the vector looks like.\n\nvector1\n\narray([1, 2, 3, 4])\n\n\nSimilar to R, Python’s Numpy vectors are displayed horizontally.\nLets try transposing it.\n\nvector1.T\n# The above is a shorthand for using the full Numpy transpose function\n# np.transpose(vector1)\n\narray([1, 2, 3, 4])\n\n\nWe see that the vector is displayed horizontally. Does this mean that numpy vectors were originally column vectors?\nLets try vector multiplication to find out.\n\nvector1 @ vector1\n\n30\n\nvector1.T @ vector1\n# the @ operator is a shorthand for vector/matrix multiplication.\n# it is equivilant to:\n# np.matmul(vector1, vector1)\n\n30\n\n\nJust like R, we see that Python assumed that we wanted the dot product of the two vectors. Even without explicitly transposing the left vector, it does so automatically.\nWe can confirm this by using the np.shape() function.\n\nnp.shape(vector1)\n\n(4,)\n\n\nThe first number of the output represents the number of rows. while the second number (it is empty) shows the number of columns. It seems to be a column vector.\nNow, to obtain the outer product we must explicitly transpose the right vector, right?\n\nvector1 @ vector1.T\n\n30\n\n\nUnexpectedly, transposing the right vector did not result in the outer product. Should we transpose the right vector again?\n\nvector1 @ np.transpose(np.transpose(vector1))\n\n30\n\nvector1 @ np.transpose(np.transpose(np.transpose(vector1)))\n\n30\n\nvector2 = np.transpose(vector1)\nvector2\n\narray([1, 2, 3, 4])\n\nnp.shape(vector2)\n\n(4,)\n\n\nIt seems like no amount of transposing the right vector gives us the result we are looking for. Additionally, assigning the transpose to a new variable does not change how the vector looks like.\nTo obtain the outer product, we must instead use the outer() Numpy function.\n\nnp.outer(vector1, vector1)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\n\n\n\nThe correct way to make vectors\nThis was a long winded demonstration of how confusing Python/Numpy can be with vectors.\nI’ll now show how to make it more intuitive.\nThere are two methods:\n\nFor np.array(), use two square brackets inside the function.\nOr use the np.mat() function (No need to use two square brackets).\n\nUsing np.array(), unlike previously, our new method will use two square brackets inside the function.\n\nvector2 = np.array([[1,2,3,4]]) # instead of np.array([1,2,3,4])\nvector1\n\narray([1, 2, 3, 4])\n\nvector2\n\narray([[1, 2, 3, 4]])\n\nnp.shape(vector2)\n\n(1, 4)\n\n\nWe can see that the new vector2 contains an extra pair of square brackets.\nImportantly, we can see that it is now a row vector by default (using the np.shape() function). Lets try vector multiplying them.\n\nvector2 @ vector2\n\nError: ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 4)\n\n\nWe see an error telling us that there is a mismatch of vector dimension. This is the behavior we should expect if Python did not automatically assume the operation we are trying to do. I prefer this behavior.\nTo get the dot product we must explicitly transpose the correct vector or call the np.dot() function.\nIf you were paying close attention, you would have remembered that the default orientation of our new vector is horizontal (row vector). Our left vector is already a row vector, so we need to transpose the right vector to get the dot product\n\nvector2 @ vector2.T\n\narray([[30]])\n\n\nBe careful when using the np.dot() or np.outer() function. Because our functions are no longer the “default” type of vector (for the lack of a better word), the function will no longer behave like it did before.\n\nnp.dot(vector2, vector2)\n\nError: ValueError: shapes (1,4) and (1,4) not aligned: 4 (dim 1) != 1 (dim 0)\n\nnp.dot(vector2.T, vector2)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\nnp.dot(vector2, vector2.T)\n\narray([[30]])\n\n\nAs you can see, just like using the @ operator, we needed to explicitly transpose the right vector to obtain the dot product we expected.\nTransposing the left matrix gave us the outer product.\n\nnp.outer(vector2, vector2)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\nnp.outer(vector2.T, vector2)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\nnp.outer(vector2, vector2.T)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\n\nWhen we used the np.outer() function, regardless of transposing or not, we obtained the outer product of the two vectors.\n\n\nSummary\n\nBy default, Numpy arrays are row vectors.\nTransposing np.array() vectors will not give you a column vector.\nYou must provide double square brackets inside the np.array([[1...n]]) function for the vector to behave conventionally."
  },
  {
    "objectID": "posts/vectors_in_r_python/index.html#just-use-matrices",
    "href": "posts/vectors_in_r_python/index.html#just-use-matrices",
    "title": "Vectors in R & Python: Just Use Matrices",
    "section": "Just Use Matrices",
    "text": "Just Use Matrices\nExperienced users might already know that I have already mixed vectors and matrices in the examples thus far. Because of these potential confusion, I recommend simply using matrices to begin with.\nWorking with matrices is nice because they behave consistently.\n\nR Examples\nHere is how you a vector as a matrix using the matrix() function.\n\ncolvec1 &lt;- matrix(data = 1:4, ncol = 1)\ncolvec1\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n\n\nWe explicitly stated that we want a matrix with one column. This is the typical form of a vector that is most expected in mathmatics.\nWe can create a row matrix by specifying that we want a matrix with only one row.\n\nrowvec1 &lt;- matrix(data = 1:4, nrow = 1)\nrowvec1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n\n\nBy being explicit, we remove any ambiguities about what orientation our vector is in.\nIf we try to vector multiply them, they will behave as we expect with no assumptions from R. If we try to multiply two vectors in the same orientation, R will give us an error.\n\ncolvec1 %*% colvec1\n\nError in colvec1 %*% colvec1: non-conformable arguments\n\nrowvec1 %*% rowvec1\n\nError in rowvec1 %*% rowvec1: non-conformable arguments\n\n\nIf we transpose our vectors, they will be in the orientation we expect.\n\nt(colvec1)\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n\nt(rowvec1)\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n[4,]    4\n\n\nTo get the dot or outer product, we must provide vectors with the appropriate orientations.\n\nrowvec1 %*% colvec1\n\n     [,1]\n[1,]   30\n\nt(colvec1) %*% colvec1\n\n     [,1]\n[1,]   30\n\ncolvec1 %*% rowvec1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    2    4    6    8\n[3,]    3    6    9   12\n[4,]    4    8   12   16\n\nt(rowvec1) %*% rowvec1\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    2    4    6    8\n[3,]    3    6    9   12\n[4,]    4    8   12   16\n\n\n\n\nPython Examples\nI will demonstrate the same behavior using Python and Numpy.\nI have already showed one way to create vectors like matrix on a previous section. This time, we will use the np.mat() function.\n\nrowvec1 = np.mat([1,2,3,4])\nrowvec1\n\nmatrix([[1, 2, 3, 4]])\n\nrowvec1.shape\n\n(1, 4)\n\n\nOne think to keep in mind is that, numpy will give us row vectors by default. We can see that our vector has 1 row, and 4 columns.\nFortunately, it is simple to get a column vector because these matrix vectors will behave as expected when we transpose them.\n\ncolvec1 = np.mat([1,2,3,4]).T\ncolvec1\n\nmatrix([[1],\n        [2],\n        [3],\n        [4]])\n\ncolvec1.shape\n\n(4, 1)\n\n\nConsistent with R, multiplying incompatible vectors, returns errors.\n\nrowvec1 @ rowvec1\n\nError: ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 1 is different from 4)\n\ncolvec1 @ colvec1\n\nError: ValueError: matmul: Input operand 1 has a mismatch in its core dimension 0, with gufunc signature (n?,k),(k,m?)-&gt;(n?,m?) (size 4 is different from 1)\n\n\nConsistent with the python examples before, np.dot() requires the left and right vector to be in the correct orientation to obtain the value we want. However, np.outer() will return the expected outer product no matter the orientation of the provided vectors.\n\nnp.dot(rowvec1, rowvec1)\n\nError: ValueError: shapes (1,4) and (1,4) not aligned: 4 (dim 1) != 1 (dim 0)\n\nnp.dot(rowvec1, colvec1)\n\nmatrix([[30]])\n\nnp.dot(colvec1, rowvec1)\n\nmatrix([[ 1,  2,  3,  4],\n        [ 2,  4,  6,  8],\n        [ 3,  6,  9, 12],\n        [ 4,  8, 12, 16]])\n\nnp.outer(rowvec1, rowvec1)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\nnp.outer(colvec1, colvec1)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\nnp.outer(rowvec1, colvec1)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])\n\nnp.outer(colvec1, rowvec1)\n\narray([[ 1,  2,  3,  4],\n       [ 2,  4,  6,  8],\n       [ 3,  6,  9, 12],\n       [ 4,  8, 12, 16]])"
  },
  {
    "objectID": "posts/vectors_in_r_python/index.html#conclusion",
    "href": "posts/vectors_in_r_python/index.html#conclusion",
    "title": "Vectors in R & Python: Just Use Matrices",
    "section": "Conclusion",
    "text": "Conclusion\nVectors in both R and Python behave in ways you might not expect. It can be confusing in what orientation vectors are created, what happens when they pass through a transpose function, or how they behave when being multiplied via operation or functions. These confusions can be mostly avoided by using both R’s and Python’s (Numpy’s) implementation of matrices.\nSmall quirks can be off putting for novices trying to learn using programming languages like R and Python. I hope this helps you avoid the confusions I faced."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\nMy blog breaks if I remove this post so I’ll be keeping it as a placeholder. Maybe I’ll write something more useful here at some point."
  }
]